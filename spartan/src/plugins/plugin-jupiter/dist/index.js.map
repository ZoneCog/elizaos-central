{"version":3,"sources":["../src/services/srv_jupiter.ts","../src/index.ts"],"sourcesContent":["import { Service, logger, type IAgentRuntime } from '@elizaos/core';\nimport { Connection, Keypair, VersionedTransaction, PublicKey } from '@solana/web3.js';\n\nexport class JupiterService extends Service {\n  private isRunning = false;\n  private connection: Connection | null = null;\n  private keypair: Keypair | null = null;\n  private registry: Record<number, any> = {};\n\n  static serviceType = 'JUPITER_SERVICE';\n  capabilityDescription = 'Provides Jupiter DEX integration for token swaps';\n\n  // Configuration constants\n  private readonly CONFIRMATION_CONFIG = {\n    MAX_ATTEMPTS: 12,\n    INITIAL_TIMEOUT: 2000,\n    MAX_TIMEOUT: 20000,\n    getDelayForAttempt: (attempt: number) => Math.min(2000 * 1.5 ** attempt, 20000),\n  };\n\n  constructor(public runtime: IAgentRuntime) {\n    super(runtime);\n    this.registry = {};\n    console.log('JUPITER_SERVICE cstr');\n  }\n\n  // return Jupiter Provider handle\n  async registerProvider(provider: any) {\n    // add to registry\n    const id = Object.values(this.registry).length + 1;\n    console.log('registered', provider.name, 'as Jupiter provider #' + id);\n    this.registry[id] = provider;\n    return id;\n  }\n\n  async getQuote({\n    inputMint,\n    outputMint,\n    amount,\n    slippageBps,\n  }: {\n    inputMint: string;\n    outputMint: string;\n    amount: number;\n    slippageBps: number;\n  }) {\n    try {\n      const quoteResponse = await fetch(\n        `https://public.jupiterapi.com/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${slippageBps}&platformFeeBps=200`\n      );\n\n      if (!quoteResponse.ok) {\n        const error = await quoteResponse.text();\n        logger.warn('Quote request failed:', {\n          status: quoteResponse.status,\n          error,\n        });\n        throw new Error(`Failed to get quote: ${error}`);\n      }\n\n      const quoteData = await quoteResponse.json();\n      return quoteData;\n    } catch (error) {\n      logger.error('Error getting Jupiter quote:', error);\n      throw error;\n    }\n  }\n\n  async executeSwap({\n    quoteResponse,\n    userPublicKey,\n    slippageBps,\n  }: {\n    quoteResponse: any;\n    userPublicKey: string;\n    slippageBps: number;\n  }) {\n    try {\n      const swapResponse = await fetch('https://public.jupiterapi.com/swap', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          quoteResponse: {\n            ...quoteResponse,\n            slippageBps,\n          },\n          userPublicKey,\n          wrapAndUnwrapSol: true,\n          computeUnitPriceMicroLamports: 5000000,\n          dynamicComputeUnitLimit: true,\n        }),\n      });\n\n      if (!swapResponse.ok) {\n        const error = await swapResponse.text();\n        throw new Error(`Failed to get swap transaction: ${error}`);\n      }\n\n      return await swapResponse.json();\n    } catch (error) {\n      logger.error('Error executing Jupiter swap:', error);\n      throw error;\n    }\n  }\n\n  async confirmTransaction(connection: Connection, signature: string): Promise<boolean> {\n    for (let i = 0; i < this.CONFIRMATION_CONFIG.MAX_ATTEMPTS; i++) {\n      try {\n        const status = await connection.getSignatureStatus(signature);\n        if (\n          status.value?.confirmationStatus === 'confirmed' ||\n          status.value?.confirmationStatus === 'finalized'\n        ) {\n          return true;\n        }\n\n        const delay = this.CONFIRMATION_CONFIG.getDelayForAttempt(i);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      } catch (error) {\n        logger.warn(`Confirmation check ${i + 1} failed:`, error);\n\n        if (i === this.CONFIRMATION_CONFIG.MAX_ATTEMPTS - 1) {\n          throw new Error('Could not confirm transaction status');\n        }\n\n        const delay = this.CONFIRMATION_CONFIG.getDelayForAttempt(i);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n    return false;\n  }\n\n  // Get token price in USDC\n  async getTokenPrice(\n    tokenMint: string,\n    quoteMint: string = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\n    inputDecimals: number = 6\n  ): Promise<number> {\n    try {\n      const baseAmount = 10 ** inputDecimals;\n      const quote = await this.getQuote({\n        inputMint: tokenMint,\n        outputMint: quoteMint,\n        amount: baseAmount, // Dynamic amount based on token decimals\n        slippageBps: 50,\n      });\n      return Number(quote.outAmount) / 10 ** inputDecimals; // Convert using same decimals\n    } catch (error) {\n      logger.error('Failed to get token price:', error);\n      return 0;\n    }\n  }\n\n  // Get best swap route\n  async getBestRoute({\n    inputMint,\n    outputMint,\n    amount,\n  }: {\n    inputMint: string;\n    outputMint: string;\n    amount: number;\n  }) {\n    try {\n      const quote = await this.getQuote({\n        inputMint,\n        outputMint,\n        amount,\n        slippageBps: 50,\n      });\n      return quote.routePlan;\n    } catch (error) {\n      logger.error('Failed to get best route:', error);\n      throw error;\n    }\n  }\n\n  async getPriceImpact({\n    inputMint,\n    outputMint,\n    amount,\n  }: {\n    inputMint: string;\n    outputMint: string;\n    amount: number;\n  }): Promise<number> {\n    try {\n      const quote = await this.getQuote({\n        inputMint,\n        outputMint,\n        amount,\n        slippageBps: 50,\n      });\n      return Number(quote.priceImpactPct);\n    } catch (error) {\n      logger.error('Failed to get price impact:', error);\n      throw error;\n    }\n  }\n\n  async getMinimumReceived({\n    inputMint,\n    outputMint,\n    amount,\n    slippageBps,\n  }: {\n    inputMint: string;\n    outputMint: string;\n    amount: number;\n    slippageBps: number;\n  }): Promise<number> {\n    try {\n      const quote = await this.getQuote({\n        inputMint,\n        outputMint,\n        amount,\n        slippageBps,\n      });\n      // Calculate minimum received based on slippage\n      const minReceived = Number(quote.outAmount) * (1 - slippageBps / 10000);\n      return minReceived;\n    } catch (error) {\n      logger.error('Failed to calculate minimum received:', error);\n      throw error;\n    }\n  }\n\n  async estimateGasFees({\n    inputMint,\n    outputMint,\n    amount,\n  }: {\n    inputMint: string;\n    outputMint: string;\n    amount: number;\n  }): Promise<{ lamports: number; sol: number }> {\n    try {\n      const quote = await this.getQuote({\n        inputMint,\n        outputMint,\n        amount,\n        slippageBps: 50,\n      });\n      const estimatedFee = quote.otherAmountThreshold || 5000; // Default to 5000 lamports if not provided\n      return {\n        lamports: estimatedFee,\n        sol: estimatedFee / 1e9, // Convert lamports to SOL\n      };\n    } catch (error) {\n      logger.error('Failed to estimate gas fees:', error);\n      throw error;\n    }\n  }\n\n  async findBestSlippage({\n    inputMint,\n    outputMint,\n    amount,\n  }: {\n    inputMint: string;\n    outputMint: string;\n    amount: number;\n  }): Promise<number> {\n    try {\n      const quote = await this.getQuote({\n        inputMint,\n        outputMint,\n        amount,\n        slippageBps: 50,\n      });\n\n      // Calculate optimal slippage based on liquidity and price impact\n      const priceImpact = Number(quote.priceImpactPct);\n      let recommendedSlippage: number;\n\n      if (priceImpact < 0.5) {\n        recommendedSlippage = 50; // 0.5%\n      } else if (priceImpact < 1) {\n        recommendedSlippage = 100; // 1%\n      } else {\n        recommendedSlippage = 200; // 2%\n      }\n\n      return recommendedSlippage;\n    } catch (error) {\n      logger.error('Failed to find best slippage:', error);\n      throw error;\n    }\n  }\n\n  async getTokenPair({\n    inputMint,\n    outputMint,\n  }: {\n    inputMint: string;\n    outputMint: string;\n  }): Promise<{\n    inputToken: any;\n    outputToken: any;\n    liquidity: number;\n    volume24h: number;\n  }> {\n    try {\n      // Fetch token pair information from Jupiter API\n      const response = await fetch(\n        `https://public.jupiterapi.com/v1/pairs/${inputMint}/${outputMint}`\n      );\n\n      if (!response.ok) {\n        throw new Error('Failed to fetch token pair data');\n      }\n\n      return await response.json();\n    } catch (error) {\n      logger.error('Failed to get token pair information:', error);\n      throw error;\n    }\n  }\n\n  async getHistoricalPrices({\n    inputMint,\n    outputMint,\n    timeframe = '24h', // Options: 1h, 24h, 7d, 30d\n  }: {\n    inputMint: string;\n    outputMint: string;\n    timeframe?: string;\n  }): Promise<Array<{ timestamp: number; price: number }>> {\n    try {\n      // Fetch historical price data from Jupiter API\n      const response = await fetch(\n        `https://public.jupiterapi.com/v1/prices/${inputMint}/${outputMint}?timeframe=${timeframe}`\n      );\n\n      if (!response.ok) {\n        throw new Error('Failed to fetch historical prices');\n      }\n\n      return await response.json();\n    } catch (error) {\n      logger.error('Failed to get historical prices:', error);\n      throw error;\n    }\n  }\n\n  async findArbitragePaths({\n    startingMint,\n    amount,\n    maxHops = 3,\n  }: {\n    startingMint: string;\n    amount: number;\n    maxHops?: number;\n  }): Promise<\n    Array<{\n      path: string[];\n      expectedReturn: number;\n      priceImpact: number;\n    }>\n  > {\n    try {\n      // Common tokens to check for arbitrage\n      const commonTokens = [\n        'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n        'So11111111111111111111111111111111111111112', // SOL\n        'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', // USDT\n      ];\n\n      const paths: Array<{\n        path: string[];\n        expectedReturn: number;\n        priceImpact: number;\n      }> = [];\n\n      // Find potential arbitrage paths\n      for (const token1 of commonTokens) {\n        if (token1 === startingMint) continue;\n\n        const quote1 = await this.getQuote({\n          inputMint: startingMint,\n          outputMint: token1,\n          amount,\n          slippageBps: 50,\n        });\n\n        for (const token2 of commonTokens) {\n          if (token2 === token1 || token2 === startingMint) continue;\n\n          const quote2 = await this.getQuote({\n            inputMint: token1,\n            outputMint: token2,\n            amount: Number(quote1.outAmount),\n            slippageBps: 50,\n          });\n\n          const finalQuote = await this.getQuote({\n            inputMint: token2,\n            outputMint: startingMint,\n            amount: Number(quote2.outAmount),\n            slippageBps: 50,\n          });\n\n          const expectedReturn = Number(finalQuote.outAmount) - amount;\n          const totalPriceImpact =\n            Number(quote1.priceImpactPct) +\n            Number(quote2.priceImpactPct) +\n            Number(finalQuote.priceImpactPct);\n\n          if (expectedReturn > 0) {\n            paths.push({\n              path: [startingMint, token1, token2, startingMint],\n              expectedReturn,\n              priceImpact: totalPriceImpact,\n            });\n          }\n        }\n      }\n\n      // Sort by expected return (highest first)\n      return paths.sort((a, b) => b.expectedReturn - a.expectedReturn);\n    } catch (error) {\n      logger.error('Failed to find arbitrage paths:', error);\n      throw error;\n    }\n  }\n\n  static async start(runtime: IAgentRuntime) {\n    console.log('JUPITER_SERVICE trying to start');\n    const service = new JupiterService(runtime);\n    await service.start();\n    return service;\n  }\n\n  static async stop(runtime: IAgentRuntime) {\n    const service = runtime.getService(this.serviceType) as JupiterService;\n    if (!service) {\n      throw new Error(this.serviceType + ' service not found');\n    }\n    await service.stop();\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      logger.warn('Jupiter service is already running');\n      return;\n    }\n    console.log('JUPITER_SERVICE starting');\n\n    try {\n      logger.info('Starting Jupiter service...');\n      this.isRunning = true;\n      logger.info('Jupiter service started successfully');\n    } catch (error) {\n      logger.error('Error starting Jupiter service:', error);\n      throw error;\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      logger.warn('Jupiter service is not running');\n      return;\n    }\n\n    try {\n      logger.info('Stopping Jupiter service...');\n      this.isRunning = false;\n      logger.info('Jupiter service stopped successfully');\n    } catch (error) {\n      logger.error('Error stopping Jupiter service:', error);\n      throw error;\n    }\n  }\n\n  isServiceRunning(): boolean {\n    return this.isRunning;\n  }\n}\n","import type { Plugin, IAgentRuntime } from '@elizaos/core';\n\nimport { JupiterService } from './services/srv_jupiter';\n\nexport const jupiterPlugin: Plugin = {\n  name: 'jupiterOS',\n  description: 'jupiter plugin',\n  actions: [],\n  evaluators: [],\n  providers: [],\n  services: [JupiterService],\n  init: async (_, runtime: IAgentRuntime) => {\n    console.log('jupiter init');\n\n    const asking = 'jupiter';\n    const serviceType = 'solana';\n    let solanaService = runtime.getService(serviceType) as any;\n    while (!solanaService) {\n      console.log(asking, 'waiting for', serviceType, 'service...');\n      solanaService = runtime.getService(serviceType) as any;\n      if (!solanaService) {\n        await new Promise((waitResolve) => setTimeout(waitResolve, 1000));\n      } else {\n        console.log(asking, 'Acquired', serviceType, 'service...');\n      }\n    }\n\n    const me = {\n      name: 'Jupiter DEX services',\n    };\n    solanaService.registerExchange(me);\n\n    console.log('jupiter init done');\n  },\n};\n\nexport default jupiterPlugin;\n"],"mappings":";AAAA,SAAS,SAAS,cAAkC;AAG7C,IAAM,iBAAN,MAAM,wBAAuB,QAAQ;AAAA,EAiB1C,YAAmB,SAAwB;AACzC,UAAM,OAAO;AADI;AAEjB,SAAK,WAAW,CAAC;AACjB,YAAQ,IAAI,sBAAsB;AAAA,EACpC;AAAA,EApBQ,YAAY;AAAA,EACZ,aAAgC;AAAA,EAChC,UAA0B;AAAA,EAC1B,WAAgC,CAAC;AAAA,EAEzC,OAAO,cAAc;AAAA,EACrB,wBAAwB;AAAA;AAAA,EAGP,sBAAsB;AAAA,IACrC,cAAc;AAAA,IACd,iBAAiB;AAAA,IACjB,aAAa;AAAA,IACb,oBAAoB,CAAC,YAAoB,KAAK,IAAI,MAAO,OAAO,SAAS,GAAK;AAAA,EAChF;AAAA;AAAA,EASA,MAAM,iBAAiB,UAAe;AAEpC,UAAM,KAAK,OAAO,OAAO,KAAK,QAAQ,EAAE,SAAS;AACjD,YAAQ,IAAI,cAAc,SAAS,MAAM,0BAA0B,EAAE;AACrE,SAAK,SAAS,EAAE,IAAI;AACpB,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,SAAS;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKG;AACD,QAAI;AACF,YAAM,gBAAgB,MAAM;AAAA,QAC1B,iDAAiD,SAAS,eAAe,UAAU,WAAW,MAAM,gBAAgB,WAAW;AAAA,MACjI;AAEA,UAAI,CAAC,cAAc,IAAI;AACrB,cAAM,QAAQ,MAAM,cAAc,KAAK;AACvC,eAAO,KAAK,yBAAyB;AAAA,UACnC,QAAQ,cAAc;AAAA,UACtB;AAAA,QACF,CAAC;AACD,cAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE;AAAA,MACjD;AAEA,YAAM,YAAY,MAAM,cAAc,KAAK;AAC3C,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO,MAAM,gCAAgC,KAAK;AAClD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,YAAY;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIG;AACD,QAAI;AACF,YAAM,eAAe,MAAM,MAAM,sCAAsC;AAAA,QACrE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,MAAM,KAAK,UAAU;AAAA,UACnB,eAAe;AAAA,YACb,GAAG;AAAA,YACH;AAAA,UACF;AAAA,UACA;AAAA,UACA,kBAAkB;AAAA,UAClB,+BAA+B;AAAA,UAC/B,yBAAyB;AAAA,QAC3B,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,aAAa,IAAI;AACpB,cAAM,QAAQ,MAAM,aAAa,KAAK;AACtC,cAAM,IAAI,MAAM,mCAAmC,KAAK,EAAE;AAAA,MAC5D;AAEA,aAAO,MAAM,aAAa,KAAK;AAAA,IACjC,SAAS,OAAO;AACd,aAAO,MAAM,iCAAiC,KAAK;AACnD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,mBAAmB,YAAwB,WAAqC;AAzGxF;AA0GI,aAAS,IAAI,GAAG,IAAI,KAAK,oBAAoB,cAAc,KAAK;AAC9D,UAAI;AACF,cAAM,SAAS,MAAM,WAAW,mBAAmB,SAAS;AAC5D,cACE,YAAO,UAAP,mBAAc,wBAAuB,iBACrC,YAAO,UAAP,mBAAc,wBAAuB,aACrC;AACA,iBAAO;AAAA,QACT;AAEA,cAAM,QAAQ,KAAK,oBAAoB,mBAAmB,CAAC;AAC3D,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,CAAC;AAAA,MAC3D,SAAS,OAAO;AACd,eAAO,KAAK,sBAAsB,IAAI,CAAC,YAAY,KAAK;AAExD,YAAI,MAAM,KAAK,oBAAoB,eAAe,GAAG;AACnD,gBAAM,IAAI,MAAM,sCAAsC;AAAA,QACxD;AAEA,cAAM,QAAQ,KAAK,oBAAoB,mBAAmB,CAAC;AAC3D,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,CAAC;AAAA,MAC3D;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,MAAM,cACJ,WACA,YAAoB,gDACpB,gBAAwB,GACP;AACjB,QAAI;AACF,YAAM,aAAa,MAAM;AACzB,YAAM,QAAQ,MAAM,KAAK,SAAS;AAAA,QAChC,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,QAAQ;AAAA;AAAA,QACR,aAAa;AAAA,MACf,CAAC;AACD,aAAO,OAAO,MAAM,SAAS,IAAI,MAAM;AAAA,IACzC,SAAS,OAAO;AACd,aAAO,MAAM,8BAA8B,KAAK;AAChD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,aAAa;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIG;AACD,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK,SAAS;AAAA,QAChC;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa;AAAA,MACf,CAAC;AACD,aAAO,MAAM;AAAA,IACf,SAAS,OAAO;AACd,aAAO,MAAM,6BAA6B,KAAK;AAC/C,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,eAAe;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIoB;AAClB,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK,SAAS;AAAA,QAChC;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa;AAAA,MACf,CAAC;AACD,aAAO,OAAO,MAAM,cAAc;AAAA,IACpC,SAAS,OAAO;AACd,aAAO,MAAM,+BAA+B,KAAK;AACjD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,mBAAmB;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKoB;AAClB,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK,SAAS;AAAA,QAChC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAED,YAAM,cAAc,OAAO,MAAM,SAAS,KAAK,IAAI,cAAc;AACjE,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO,MAAM,yCAAyC,KAAK;AAC3D,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAI+C;AAC7C,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK,SAAS;AAAA,QAChC;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa;AAAA,MACf,CAAC;AACD,YAAM,eAAe,MAAM,wBAAwB;AACnD,aAAO;AAAA,QACL,UAAU;AAAA,QACV,KAAK,eAAe;AAAA;AAAA,MACtB;AAAA,IACF,SAAS,OAAO;AACd,aAAO,MAAM,gCAAgC,KAAK;AAClD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIoB;AAClB,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK,SAAS;AAAA,QAChC;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa;AAAA,MACf,CAAC;AAGD,YAAM,cAAc,OAAO,MAAM,cAAc;AAC/C,UAAI;AAEJ,UAAI,cAAc,KAAK;AACrB,8BAAsB;AAAA,MACxB,WAAW,cAAc,GAAG;AAC1B,8BAAsB;AAAA,MACxB,OAAO;AACL,8BAAsB;AAAA,MACxB;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO,MAAM,iCAAiC,KAAK;AACnD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,aAAa;AAAA,IACjB;AAAA,IACA;AAAA,EACF,GAQG;AACD,QAAI;AAEF,YAAM,WAAW,MAAM;AAAA,QACrB,0CAA0C,SAAS,IAAI,UAAU;AAAA,MACnE;AAEA,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,iCAAiC;AAAA,MACnD;AAEA,aAAO,MAAM,SAAS,KAAK;AAAA,IAC7B,SAAS,OAAO;AACd,aAAO,MAAM,yCAAyC,KAAK;AAC3D,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,oBAAoB;AAAA,IACxB;AAAA,IACA;AAAA,IACA,YAAY;AAAA;AAAA,EACd,GAIyD;AACvD,QAAI;AAEF,YAAM,WAAW,MAAM;AAAA,QACrB,2CAA2C,SAAS,IAAI,UAAU,cAAc,SAAS;AAAA,MAC3F;AAEA,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,mCAAmC;AAAA,MACrD;AAEA,aAAO,MAAM,SAAS,KAAK;AAAA,IAC7B,SAAS,OAAO;AACd,aAAO,MAAM,oCAAoC,KAAK;AACtD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,mBAAmB;AAAA,IACvB;AAAA,IACA;AAAA,IACA,UAAU;AAAA,EACZ,GAUE;AACA,QAAI;AAEF,YAAM,eAAe;AAAA,QACnB;AAAA;AAAA,QACA;AAAA;AAAA,QACA;AAAA;AAAA,MACF;AAEA,YAAM,QAID,CAAC;AAGN,iBAAW,UAAU,cAAc;AACjC,YAAI,WAAW,aAAc;AAE7B,cAAM,SAAS,MAAM,KAAK,SAAS;AAAA,UACjC,WAAW;AAAA,UACX,YAAY;AAAA,UACZ;AAAA,UACA,aAAa;AAAA,QACf,CAAC;AAED,mBAAW,UAAU,cAAc;AACjC,cAAI,WAAW,UAAU,WAAW,aAAc;AAElD,gBAAM,SAAS,MAAM,KAAK,SAAS;AAAA,YACjC,WAAW;AAAA,YACX,YAAY;AAAA,YACZ,QAAQ,OAAO,OAAO,SAAS;AAAA,YAC/B,aAAa;AAAA,UACf,CAAC;AAED,gBAAM,aAAa,MAAM,KAAK,SAAS;AAAA,YACrC,WAAW;AAAA,YACX,YAAY;AAAA,YACZ,QAAQ,OAAO,OAAO,SAAS;AAAA,YAC/B,aAAa;AAAA,UACf,CAAC;AAED,gBAAM,iBAAiB,OAAO,WAAW,SAAS,IAAI;AACtD,gBAAM,mBACJ,OAAO,OAAO,cAAc,IAC5B,OAAO,OAAO,cAAc,IAC5B,OAAO,WAAW,cAAc;AAElC,cAAI,iBAAiB,GAAG;AACtB,kBAAM,KAAK;AAAA,cACT,MAAM,CAAC,cAAc,QAAQ,QAAQ,YAAY;AAAA,cACjD;AAAA,cACA,aAAa;AAAA,YACf,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAGA,aAAO,MAAM,KAAK,CAAC,GAAG,MAAM,EAAE,iBAAiB,EAAE,cAAc;AAAA,IACjE,SAAS,OAAO;AACd,aAAO,MAAM,mCAAmC,KAAK;AACrD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,aAAa,MAAM,SAAwB;AACzC,YAAQ,IAAI,iCAAiC;AAC7C,UAAM,UAAU,IAAI,gBAAe,OAAO;AAC1C,UAAM,QAAQ,MAAM;AACpB,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,KAAK,SAAwB;AACxC,UAAM,UAAU,QAAQ,WAAW,KAAK,WAAW;AACnD,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,KAAK,cAAc,oBAAoB;AAAA,IACzD;AACA,UAAM,QAAQ,KAAK;AAAA,EACrB;AAAA,EAEA,MAAM,QAAuB;AAC3B,QAAI,KAAK,WAAW;AAClB,aAAO,KAAK,oCAAoC;AAChD;AAAA,IACF;AACA,YAAQ,IAAI,0BAA0B;AAEtC,QAAI;AACF,aAAO,KAAK,6BAA6B;AACzC,WAAK,YAAY;AACjB,aAAO,KAAK,sCAAsC;AAAA,IACpD,SAAS,OAAO;AACd,aAAO,MAAM,mCAAmC,KAAK;AACrD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,OAAsB;AAC1B,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO,KAAK,gCAAgC;AAC5C;AAAA,IACF;AAEA,QAAI;AACF,aAAO,KAAK,6BAA6B;AACzC,WAAK,YAAY;AACjB,aAAO,KAAK,sCAAsC;AAAA,IACpD,SAAS,OAAO;AACd,aAAO,MAAM,mCAAmC,KAAK;AACrD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,mBAA4B;AAC1B,WAAO,KAAK;AAAA,EACd;AACF;;;ACzdO,IAAM,gBAAwB;AAAA,EACnC,MAAM;AAAA,EACN,aAAa;AAAA,EACb,SAAS,CAAC;AAAA,EACV,YAAY,CAAC;AAAA,EACb,WAAW,CAAC;AAAA,EACZ,UAAU,CAAC,cAAc;AAAA,EACzB,MAAM,OAAO,GAAG,YAA2B;AACzC,YAAQ,IAAI,cAAc;AAE1B,UAAM,SAAS;AACf,UAAM,cAAc;AACpB,QAAI,gBAAgB,QAAQ,WAAW,WAAW;AAClD,WAAO,CAAC,eAAe;AACrB,cAAQ,IAAI,QAAQ,eAAe,aAAa,YAAY;AAC5D,sBAAgB,QAAQ,WAAW,WAAW;AAC9C,UAAI,CAAC,eAAe;AAClB,cAAM,IAAI,QAAQ,CAAC,gBAAgB,WAAW,aAAa,GAAI,CAAC;AAAA,MAClE,OAAO;AACL,gBAAQ,IAAI,QAAQ,YAAY,aAAa,YAAY;AAAA,MAC3D;AAAA,IACF;AAEA,UAAM,KAAK;AAAA,MACT,MAAM;AAAA,IACR;AACA,kBAAc,iBAAiB,EAAE;AAEjC,YAAQ,IAAI,mBAAmB;AAAA,EACjC;AACF;AAEA,IAAO,gBAAQ;","names":[]}