{"version":3,"sources":["../src/index.ts","../src/actions/getPrice/index.ts","../src/environment.ts","../src/actions/getPrice/examples.ts","../src/actions/getPrice/service.ts","../src/actions/getPrice/template.ts","../src/actions/getPrice/validation.ts","../src/tasks/coinmarketcap.ts","../src/providers/trending.ts"],"sourcesContent":["import { type Plugin, type IAgentRuntime, logger } from \"@elizaos/core\";\nimport getPrice from \"./actions/getPrice\";\n\n//import { CoinmarketcapService } from './service';\nimport Coinmarketcap from './tasks/coinmarketcap';\n\nimport { trendingProvider } from './providers/trending';\n\nexport const coinmarketcapPlugin: Plugin = {\n    name: \"coinmarketcap\",\n    description: \"CoinMarketCap Plugin for Eliza\",\n    actions: [getPrice],\n    evaluators: [],\n    providers: [trendingProvider],\n    init: async (_, runtime: IAgentRuntime) => {\n      const worldId = runtime.agentId; // this is global data for the agent\n\n      // first, get all tasks with tags \"queue\", \"repeat\", \"degen_intel\" and delete them\n      const tasks = await runtime.getTasks({\n        tags: ['queue', 'repeat', 'plugin_coinmarketcap'],\n      });\n\n      for (const task of tasks) {\n        await runtime.deleteTask(task.id);\n      }\n\n      runtime.registerTaskWorker({\n        name: 'COINMARKETCAP_SYNC_TRENDING',\n        validate: async (_runtime, _message, _state) => {\n          return true; // TODO: validate after certain time\n        },\n        execute: async (runtime, _options, task) => {\n          const cmc = new Coinmarketcap(runtime);\n          try {\n            await cmc.syncTokens();\n            //await birdeye.syncTrendingTokens('base');\n          } catch (error) {\n            logger.error('Failed to sync trending tokens', error);\n            // kill this task\n            runtime.deleteTask(task.id);\n          }\n        },\n      });\n\n      runtime.createTask({\n        name: 'COINMARKETCAP_SYNC_TRENDING',\n        description: 'Sync trending tokens from Birdeye',\n        worldId,\n        metadata: {\n          createdAt: Date.now(),\n          updatedAt: Date.now(),\n          updateInterval: 1000 * 60 * 60, // 1 hour\n        },\n        tags: ['queue', 'repeat', 'plugin_birdeye', 'immediate'],\n      });\n\n      /*\n      const plugins = runtime.plugins.map((p) => p.name);\n      let notUsed = true;\n\n      // check for birdeeye key, if have then register provider\n      if (runtime.getSetting('BIRDEYE_API_KEY')) {\n        runtime.registerContextProvider(birdeyeTrendingProvider);\n        runtime.registerContextProvider(birdeyeTradePortfolioProvider);\n        notUsed = false;\n      }\n\n      if (notUsed) {\n        logger.warn(\n          'degen-intel plugin is included but not providing any value (COINMARKETCAP_API_KEY/BIRDEYE_API_KEY or twitter are suggested)'\n        );\n      }\n      */\n    },\n};\n\nexport default coinmarketcapPlugin;\n","import {\n    logger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport { validateCoinMarketCapConfig } from \"../../environment\";\nimport { priceExamples } from \"./examples\";\nimport { createPriceService } from \"./service\";\nimport { getPriceTemplate } from \"./template\";\nimport type { GetPriceContent } from \"./types\";\nimport { isGetPriceContent } from \"./validation\";\n\nexport default {\n    name: \"GET_PRICE\",\n    similes: [\n        \"CHECK_PRICE\",\n        \"PRICE_CHECK\",\n        \"GET_CRYPTO_PRICE\",\n        \"CHECK_CRYPTO_PRICE\",\n        \"GET_TOKEN_PRICE\",\n        \"CHECK_TOKEN_PRICE\",\n    ],\n    // eslint-disable-next-line\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoinMarketCapConfig(runtime);\n        return true;\n    },\n    description: \"Get the current price of a cryptocurrency from CoinMarketCap\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        logger.log(\"Starting CoinMarketCap GET_PRICE handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            //currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        try {\n            // Compose and generate price check content\n            const priceContext = composeContext({\n                state: currentState,\n                template: getPriceTemplate,\n            });\n\n            /*\n            const content = (await generateObjectDeprecated({\n                runtime,\n                context: priceContext,\n                modelClass: ModelClass.SMALL,\n            })) as unknown as GetPriceContent;\n            */\n            const content = await runtime.useModel(ModelType.OBJECT_SMALL, {\n              prompt: priceContext,\n            });\n\n            // Validate content\n            if (!isGetPriceContent(content)) {\n                throw new Error(\"Invalid price check content\");\n            }\n\n            // Get price from CoinMarketCap\n            const config = await validateCoinMarketCapConfig(runtime);\n\n            const priceService = createPriceService(\n                config.COINMARKETCAP_API_KEY\n            );\n\n            try {\n                const priceData = await priceService.getPrice(\n                    content.symbol,\n                    content.currency\n                );\n                logger.success(\n                    `Price retrieved successfully! ${content.symbol}: ${priceData.price} ${content.currency.toUpperCase()}`\n                );\n\n                if (callback) {\n                    callback({\n                        text: `The current price of ${content.symbol} is ${priceData.price} ${content.currency.toUpperCase()}`,\n                        content: {\n                            symbol: content.symbol,\n                            currency: content.currency,\n                            ...priceData,\n                        },\n                    });\n                }\n\n                return true;\n            } catch (error) {\n                logger.error(\"Error in GET_PRICE handler:\", error);\n                if (callback) {\n                    callback({\n                        text: `Error fetching price: ${error.message}`,\n                        content: { error: error.message },\n                    });\n                }\n                return false;\n            }\n        } catch (error) {\n            logger.error(\"Error in GET_PRICE handler:\", error);\n            if (callback) {\n                callback({\n                    text: `Error fetching price: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples: priceExamples,\n} as Action;\n","import type { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const coinmarketcapEnvSchema = z.object({\n    COINMARKETCAP_API_KEY: z\n        .string()\n        .min(1, \"CoinMarketCap API key is required\"),\n});\n\nexport type CoinMarketCapConfig = z.infer<typeof coinmarketcapEnvSchema>;\n\nexport async function validateCoinMarketCapConfig(\n    runtime: IAgentRuntime\n): Promise<CoinMarketCapConfig> {\n    try {\n        const config = {\n            COINMARKETCAP_API_KEY: runtime.getSetting(\"COINMARKETCAP_API_KEY\"),\n        };\n\n        return coinmarketcapEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `CoinMarketCap configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import type { ActionExample } from \"@elizaos/core\";\n\nexport const priceExamples: ActionExample[][] = [\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"What's the current price of Bitcoin?\",\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me check the current Bitcoin price for you.\",\n                action: \"GET_PRICE\",\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"The current price of BTC is 65,432.21 USD\",\n            },\n        },\n    ],\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Check ETH price in EUR\",\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll check the current Ethereum price in EUR.\",\n                action: \"GET_PRICE\",\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"The current price of ETH is 2,345.67 EUR\",\n            },\n        },\n    ],\n];\n","import axios from \"axios\";\nimport type { ApiResponse, PriceData } from \"./types\";\n\nconst BASE_URL = \"https://pro-api.coinmarketcap.com/v1\";\n\nexport const createPriceService = (apiKey: string) => {\n    const client = axios.create({\n        baseURL: BASE_URL,\n        headers: {\n            \"X-CMC_PRO_API_KEY\": apiKey,\n            Accept: \"application/json\",\n        },\n    });\n\n    const getPrice = async (\n        symbol: string,\n        currency: string\n    ): Promise<PriceData> => {\n        const normalizedSymbol = symbol.toUpperCase().trim();\n        const normalizedCurrency = currency.toUpperCase().trim();\n\n        try {\n            const response = await client.get<ApiResponse>(\n                \"/cryptocurrency/quotes/latest\",\n                {\n                    params: {\n                        symbol: normalizedSymbol,\n                        convert: normalizedCurrency,\n                    },\n                }\n            );\n\n            console.log(\n                \"API Response:\",\n                JSON.stringify(response.data, null, 2)\n            );\n\n            const symbolData = response.data.data[normalizedSymbol];\n            if (!symbolData) {\n                throw new Error(\n                    `No data found for symbol: ${normalizedSymbol}`\n                );\n            }\n\n            const quoteData = symbolData.quote[normalizedCurrency];\n            if (!quoteData) {\n                throw new Error(\n                    `No quote data found for currency: ${normalizedCurrency}`\n                );\n            }\n\n            return {\n                price: quoteData.price,\n                marketCap: quoteData.market_cap,\n                volume24h: quoteData.volume_24h,\n                percentChange24h: quoteData.percent_change_24h,\n            };\n        } catch (error) {\n            if (axios.isAxiosError(error)) {\n                const errorMessage =\n                    error.response?.data?.status?.error_message ||\n                    error.message;\n                console.error(\"API Error:\", errorMessage);\n                throw new Error(`API Error: ${errorMessage}`);\n            }\n            throw error;\n        }\n    };\n\n    return { getPrice };\n};\n","export const getPriceTemplate = `Respond with a JSON object containing BOTH symbol and currency. Currency must default to \"USD\" if not specified.\n\nHere are the cryptocurrency symbol mappings:\n- bitcoin/btc -> BTC\n- ethereum/eth -> ETH\n- solana/sol -> SOL\n- cardano/ada -> ADA\n- ripple/xrp -> XRP\n- dogecoin/doge -> DOGE\n- polkadot/dot -> DOT\n- usdc -> USDC\n- tether/usdt -> USDT\n\nIMPORTANT: Response must ALWAYS include both \"symbol\" and \"currency\" fields.\n\nExample response:\n\\`\\`\\`json\n{\n    \"symbol\": \"BTC\",\n    \"currency\": \"USD\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nExtract the cryptocurrency from the most recent message. Always include currency (default \"USD\").\nRespond with a JSON markdown block containing both symbol and currency.`;\n","import { z } from \"zod\";\nimport type { GetPriceContent } from \"./types\";\n\nexport const GetPriceSchema = z.object({\n    symbol: z.string(),\n    currency: z.string().default(\"USD\"),\n});\n\nexport function isGetPriceContent(\n    content: GetPriceContent\n): content is GetPriceContent {\n    return (\n        typeof content.symbol === \"string\" &&\n        typeof content.currency === \"string\"\n    );\n}\n","import { type IAgentRuntime, logger } from '@elizaos/core';\n//import type { IToken } from '../types';\n\nexport default class Coinmarketcap {\n  runtime: IAgentRuntime;\n\n  constructor(runtime: IAgentRuntime) {\n    this.runtime = runtime;\n  }\n\n  async syncTokens(): Promise<boolean> {\n    const options = {\n      method: 'GET',\n      headers: {\n        accept: 'application/json',\n        'X-CMC_PRO_API_KEY': this.runtime.getSetting('COINMARKETCAP_API_KEY'),\n      },\n    };\n\n    const res = await fetch(\n      'https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest',\n      options\n    );\n\n    const resp = await res.json();\n    //console.log('resp', resp)\n    const data = resp?.data;\n\n    const ops = [];\n    const tokens = [];\n    for (const token of data) {\n      /** If the token is not a Layer 1 token it will have platform defined */\n      if (token.platform !== null) {\n        const allowed = ['solana', 'base', 'ethereum'];\n        if (!allowed.includes(token.platform.slug)) {\n          continue;\n        }\n      }\n\n      const address = token?.platform?.token_address ?? token.slug;\n\n      const data2: IToken = {\n        provider: 'coinmarketcap',\n        chain: token?.platform?.slug ?? 'L1',\n        address,\n        decimals: null,\n        liquidity: null,\n        logoURI: `https://s2.coinmarketcap.com/static/img/coins/128x128/${token.id}.png`,\n        name: token.name,\n        symbol: token.symbol,\n        volume24hUSD: token?.quote?.USD?.volume_24h,\n        rank: token.cmc_rank,\n        marketcap: 0,\n        price: token?.quote?.USD?.price,\n        price24hChangePercent: token?.quote?.USD?.percent_change_24h,\n        last_updated: new Date(token.last_updated),\n      };\n      tokens.push(data2);\n\n      ops.push({\n        updateOne: {\n          filter: {\n            provider: 'coinmarketcap',\n            rank: data2.rank,\n          },\n          update: {\n            $set: data2,\n          },\n          upsert: true,\n        },\n      });\n    }\n\n    // this isn't right\n    //const writeResult = await this.runtime.databaseAdapter.Token.bulkWrite(ops);\n    await this.runtime.setCache<IToken[]>('coinmarketcap_sync', tokens);\n    //logger.info(\"Coinmarketcap sync done\");\n    //logger.info(ops, \"Coinmarketcap sync resulted in:\");\n\n    return true;\n  }\n}\n","import type { Action, IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { addHeader, composeActionExamples, formatActionNames, formatActions } from '@elizaos/core';\nimport type { IToken } from '../types';\n\n/**\n * Provider for CMC latest coins\n *\n * @typedef {import('./Provider').Provider} Provider\n * @typedef {import('./Runtime').IAgentRuntime} IAgentRuntime\n * @typedef {import('./Memory').Memory} Memory\n * @typedef {import('./State').State} State\n * @typedef {import('./Action').Action} Action\n *\n * @type {Provider}\n * @property {string} name - The name of the provider\n * @property {string} description - Description of the provider\n * @property {number} position - The position of the provider\n * @property {Function} get - Asynchronous function to get actions that validate for a given message\n *\n * @param {IAgentRuntime} runtime - The agent runtime\n * @param {Memory} message - The message memory\n * @param {State} state - The state of the agent\n * @returns {Object} Object containing data, values, and text related to actions\n */\nexport const trendingProvider: Provider = {\n  name: 'COINMARKETCAP_CURRENCY_LATEST',\n  description: 'Coinmarketcaps latest information about the cryptocurrencies',\n  dynamic: true,\n  //position: -1,\n  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n    // Get all sentiments\n    const tokens = (await runtime.getCache<IToken[]>('coinmarketcap_sync')) || [];\n    //console.log('intel:provider - cmc tokens', sentimentData.length, 'records')\n    if (!tokens.length) {\n      logger.warn('No CMC token data found');\n      return false;\n    }\n\n    //console.log('CMC token data', tokens)\n\n    /*\n    name: \"Bitcoin\",\n    rank: 1,\n    chain: \"L1\",\n    price: 93768.60351119141,\n    symbol: \"BTC\",\n    address: \"bitcoin\",\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/128x128/1.png\",\n    decimals: null,\n    provider: \"coinmarketcap\",\n    liquidity: null,\n    marketcap: 0,\n    last_updated: \"2025-04-23T22:50:00.000Z\",\n    volume24hUSD: 43588891208.92652,\n    price24hChangePercent: 1.17760374,\n*/\n\n    let latestTxt =\n      '\\nCurrent CoinMarketCap list of all active cryptocurrencies with latest market data:';\n    let idx = 1;\n    // maybe filter by active chains\n    const reduceTokens = tokens.map((t) => {\n      const obj = {\n        name: t.name,\n        rank: t.rank,\n        chain: t.chain,\n        priceUsd: t.price,\n        symbol: t.symbol,\n        address: t.address,\n        // skip logo, decimals\n        // liquidity/marketcap are optimal\n        // last_updated\n        volume24hUSD: t.volume24hUSD,\n        price24hChangePercent: t.price24hChangePercent,\n      };\n      // optional fields\n      if (t.liquidity !== null) obj.liquidity = t.liquidity;\n      if (t.marketcap !== 0) obj.marketcap = t.marketcap;\n      return obj;\n    });\n    /*\n    for (const t of tokens) {\n      if (!sentiment?.occuringTokens?.length) continue;\n      sentiments += `ENTRY ${idx}\\nTIME: ${sentiment.timeslot}\\nTOKEN ANALYSIS:\\n`;\n      for (const token of sentiment.occuringTokens) {\n        sentiments += `${token.token} - Sentiment: ${token.sentiment}\\n${token.reason}\\n`;\n      }\n      latestTxt += '\\n-------------------\\n';\n      idx++;\n    }\n    */\n    latestTxt += '\\n' + JSON.stringify(reduceTokens) + '\\n';\n\n    //console.log('intel:provider - cmc token text', latestTxt)\n\n    const data = {\n      tokens,\n    };\n\n    const values = {};\n\n    // Combine all text sections\n    const text = latestTxt + '\\n';\n\n    return {\n      data,\n      values,\n      text,\n    };\n    return false;\n  },\n};\n"],"mappings":";AAAA,SAA0C,UAAAA,eAAc;;;ACAxD;AAAA,EACI,UAAAC;AAAA,OAMG;;;ACNP,SAAS,SAAS;AAEX,IAAM,yBAAyB,EAAE,OAAO;AAAA,EAC3C,uBAAuB,EAClB,OAAO,EACP,IAAI,GAAG,mCAAmC;AACnD,CAAC;AAID,eAAsB,4BAClB,SAC4B;AAC5B,MAAI;AACA,UAAM,SAAS;AAAA,MACX,uBAAuB,QAAQ,WAAW,uBAAuB;AAAA,IACrE;AAEA,WAAO,uBAAuB,MAAM,MAAM;AAAA,EAC9C,SAAS,OAAO;AACZ,QAAI,iBAAiB,EAAE,UAAU;AAC7B,YAAM,gBAAgB,MAAM,OACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,KAAK,GAAG,CAAC,KAAK,IAAI,OAAO,EAAE,EACpD,KAAK,IAAI;AACd,YAAM,IAAI;AAAA,QACN;AAAA,EAAmD,aAAa;AAAA,MACpE;AAAA,IACJ;AACA,UAAM;AAAA,EACV;AACJ;;;AC7BO,IAAM,gBAAmC;AAAA,EAC5C;AAAA,IACI;AAAA,MACI,MAAM;AAAA,MACN,SAAS;AAAA,QACL,MAAM;AAAA,MACV;AAAA,IACJ;AAAA,IACA;AAAA,MACI,MAAM;AAAA,MACN,SAAS;AAAA,QACL,MAAM;AAAA,QACN,QAAQ;AAAA,MACZ;AAAA,IACJ;AAAA,IACA;AAAA,MACI,MAAM;AAAA,MACN,SAAS;AAAA,QACL,MAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAAA,EACA;AAAA,IACI;AAAA,MACI,MAAM;AAAA,MACN,SAAS;AAAA,QACL,MAAM;AAAA,MACV;AAAA,IACJ;AAAA,IACA;AAAA,MACI,MAAM;AAAA,MACN,SAAS;AAAA,QACL,MAAM;AAAA,QACN,QAAQ;AAAA,MACZ;AAAA,IACJ;AAAA,IACA;AAAA,MACI,MAAM;AAAA,MACN,SAAS;AAAA,QACL,MAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AACJ;;;AC7CA,OAAO,WAAW;AAGlB,IAAM,WAAW;AAEV,IAAM,qBAAqB,CAAC,WAAmB;AAClD,QAAM,SAAS,MAAM,OAAO;AAAA,IACxB,SAAS;AAAA,IACT,SAAS;AAAA,MACL,qBAAqB;AAAA,MACrB,QAAQ;AAAA,IACZ;AAAA,EACJ,CAAC;AAED,QAAM,WAAW,OACb,QACA,aACqB;AAjB7B;AAkBQ,UAAM,mBAAmB,OAAO,YAAY,EAAE,KAAK;AACnD,UAAM,qBAAqB,SAAS,YAAY,EAAE,KAAK;AAEvD,QAAI;AACA,YAAM,WAAW,MAAM,OAAO;AAAA,QAC1B;AAAA,QACA;AAAA,UACI,QAAQ;AAAA,YACJ,QAAQ;AAAA,YACR,SAAS;AAAA,UACb;AAAA,QACJ;AAAA,MACJ;AAEA,cAAQ;AAAA,QACJ;AAAA,QACA,KAAK,UAAU,SAAS,MAAM,MAAM,CAAC;AAAA,MACzC;AAEA,YAAM,aAAa,SAAS,KAAK,KAAK,gBAAgB;AACtD,UAAI,CAAC,YAAY;AACb,cAAM,IAAI;AAAA,UACN,6BAA6B,gBAAgB;AAAA,QACjD;AAAA,MACJ;AAEA,YAAM,YAAY,WAAW,MAAM,kBAAkB;AACrD,UAAI,CAAC,WAAW;AACZ,cAAM,IAAI;AAAA,UACN,qCAAqC,kBAAkB;AAAA,QAC3D;AAAA,MACJ;AAEA,aAAO;AAAA,QACH,OAAO,UAAU;AAAA,QACjB,WAAW,UAAU;AAAA,QACrB,WAAW,UAAU;AAAA,QACrB,kBAAkB,UAAU;AAAA,MAChC;AAAA,IACJ,SAAS,OAAO;AACZ,UAAI,MAAM,aAAa,KAAK,GAAG;AAC3B,cAAM,iBACF,uBAAM,aAAN,mBAAgB,SAAhB,mBAAsB,WAAtB,mBAA8B,kBAC9B,MAAM;AACV,gBAAQ,MAAM,cAAc,YAAY;AACxC,cAAM,IAAI,MAAM,cAAc,YAAY,EAAE;AAAA,MAChD;AACA,YAAM;AAAA,IACV;AAAA,EACJ;AAEA,SAAO,EAAE,SAAS;AACtB;;;ACtEO,IAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAhC,SAAS,KAAAC,UAAS;AAGX,IAAM,iBAAiBA,GAAE,OAAO;AAAA,EACnC,QAAQA,GAAE,OAAO;AAAA,EACjB,UAAUA,GAAE,OAAO,EAAE,QAAQ,KAAK;AACtC,CAAC;AAEM,SAAS,kBACZ,SAC0B;AAC1B,SACI,OAAO,QAAQ,WAAW,YAC1B,OAAO,QAAQ,aAAa;AAEpC;;;ALAA,IAAO,mBAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA;AAAA,EAEA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,4BAA4B,OAAO;AACzC,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AACnB,IAAAC,QAAO,IAAI,6CAA6C;AAGxD,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AAAA,IAEP;AAEA,QAAI;AAEA,YAAM,eAAe,eAAe;AAAA,QAChC,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AASD,YAAM,UAAU,MAAM,QAAQ,SAAS,UAAU,cAAc;AAAA,QAC7D,QAAQ;AAAA,MACV,CAAC;AAGD,UAAI,CAAC,kBAAkB,OAAO,GAAG;AAC7B,cAAM,IAAI,MAAM,6BAA6B;AAAA,MACjD;AAGA,YAAM,SAAS,MAAM,4BAA4B,OAAO;AAExD,YAAM,eAAe;AAAA,QACjB,OAAO;AAAA,MACX;AAEA,UAAI;AACA,cAAM,YAAY,MAAM,aAAa;AAAA,UACjC,QAAQ;AAAA,UACR,QAAQ;AAAA,QACZ;AACA,QAAAA,QAAO;AAAA,UACH,iCAAiC,QAAQ,MAAM,KAAK,UAAU,KAAK,IAAI,QAAQ,SAAS,YAAY,CAAC;AAAA,QACzG;AAEA,YAAI,UAAU;AACV,mBAAS;AAAA,YACL,MAAM,wBAAwB,QAAQ,MAAM,OAAO,UAAU,KAAK,IAAI,QAAQ,SAAS,YAAY,CAAC;AAAA,YACpG,SAAS;AAAA,cACL,QAAQ,QAAQ;AAAA,cAChB,UAAU,QAAQ;AAAA,cAClB,GAAG;AAAA,YACP;AAAA,UACJ,CAAC;AAAA,QACL;AAEA,eAAO;AAAA,MACX,SAAS,OAAO;AACZ,QAAAA,QAAO,MAAM,+BAA+B,KAAK;AACjD,YAAI,UAAU;AACV,mBAAS;AAAA,YACL,MAAM,yBAAyB,MAAM,OAAO;AAAA,YAC5C,SAAS,EAAE,OAAO,MAAM,QAAQ;AAAA,UACpC,CAAC;AAAA,QACL;AACA,eAAO;AAAA,MACX;AAAA,IACJ,SAAS,OAAO;AACZ,MAAAA,QAAO,MAAM,+BAA+B,KAAK;AACjD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM,yBAAyB,MAAM,OAAO;AAAA,UAC5C,SAAS,EAAE,OAAO,MAAM,QAAQ;AAAA,QACpC,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,UAAU;AACd;;;AMtHA,IAAqB,gBAArB,MAAmC;AAAA,EACjC;AAAA,EAEA,YAAY,SAAwB;AAClC,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,aAA+B;AAVvC;AAWI,UAAM,UAAU;AAAA,MACd,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,QAAQ;AAAA,QACR,qBAAqB,KAAK,QAAQ,WAAW,uBAAuB;AAAA,MACtE;AAAA,IACF;AAEA,UAAM,MAAM,MAAM;AAAA,MAChB;AAAA,MACA;AAAA,IACF;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAE5B,UAAM,OAAO,6BAAM;AAEnB,UAAM,MAAM,CAAC;AACb,UAAM,SAAS,CAAC;AAChB,eAAW,SAAS,MAAM;AAExB,UAAI,MAAM,aAAa,MAAM;AAC3B,cAAM,UAAU,CAAC,UAAU,QAAQ,UAAU;AAC7C,YAAI,CAAC,QAAQ,SAAS,MAAM,SAAS,IAAI,GAAG;AAC1C;AAAA,QACF;AAAA,MACF;AAEA,YAAM,YAAU,oCAAO,aAAP,mBAAiB,kBAAiB,MAAM;AAExD,YAAM,QAAgB;AAAA,QACpB,UAAU;AAAA,QACV,SAAO,oCAAO,aAAP,mBAAiB,SAAQ;AAAA,QAChC;AAAA,QACA,UAAU;AAAA,QACV,WAAW;AAAA,QACX,SAAS,yDAAyD,MAAM,EAAE;AAAA,QAC1E,MAAM,MAAM;AAAA,QACZ,QAAQ,MAAM;AAAA,QACd,eAAc,0CAAO,UAAP,mBAAc,QAAd,mBAAmB;AAAA,QACjC,MAAM,MAAM;AAAA,QACZ,WAAW;AAAA,QACX,QAAO,0CAAO,UAAP,mBAAc,QAAd,mBAAmB;AAAA,QAC1B,wBAAuB,0CAAO,UAAP,mBAAc,QAAd,mBAAmB;AAAA,QAC1C,cAAc,IAAI,KAAK,MAAM,YAAY;AAAA,MAC3C;AACA,aAAO,KAAK,KAAK;AAEjB,UAAI,KAAK;AAAA,QACP,WAAW;AAAA,UACT,QAAQ;AAAA,YACN,UAAU;AAAA,YACV,MAAM,MAAM;AAAA,UACd;AAAA,UACA,QAAQ;AAAA,YACN,MAAM;AAAA,UACR;AAAA,UACA,QAAQ;AAAA,QACV;AAAA,MACF,CAAC;AAAA,IACH;AAIA,UAAM,KAAK,QAAQ,SAAmB,sBAAsB,MAAM;AAIlE,WAAO;AAAA,EACT;AACF;;;ACzDO,IAAM,mBAA6B;AAAA,EACxC,MAAM;AAAA,EACN,aAAa;AAAA,EACb,SAAS;AAAA;AAAA,EAET,KAAK,OAAO,SAAwB,SAAiB,UAAiB;AAEpE,UAAM,SAAU,MAAM,QAAQ,SAAmB,oBAAoB,KAAM,CAAC;AAE5E,QAAI,CAAC,OAAO,QAAQ;AAClB,aAAO,KAAK,yBAAyB;AACrC,aAAO;AAAA,IACT;AAqBA,QAAI,YACF;AACF,QAAI,MAAM;AAEV,UAAM,eAAe,OAAO,IAAI,CAAC,MAAM;AACrC,YAAM,MAAM;AAAA,QACV,MAAM,EAAE;AAAA,QACR,MAAM,EAAE;AAAA,QACR,OAAO,EAAE;AAAA,QACT,UAAU,EAAE;AAAA,QACZ,QAAQ,EAAE;AAAA,QACV,SAAS,EAAE;AAAA;AAAA;AAAA;AAAA,QAIX,cAAc,EAAE;AAAA,QAChB,uBAAuB,EAAE;AAAA,MAC3B;AAEA,UAAI,EAAE,cAAc,KAAM,KAAI,YAAY,EAAE;AAC5C,UAAI,EAAE,cAAc,EAAG,KAAI,YAAY,EAAE;AACzC,aAAO;AAAA,IACT,CAAC;AAYD,iBAAa,OAAO,KAAK,UAAU,YAAY,IAAI;AAInD,UAAM,OAAO;AAAA,MACX;AAAA,IACF;AAEA,UAAM,SAAS,CAAC;AAGhB,UAAM,OAAO,YAAY;AAEzB,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;;;ARvGO,IAAM,sBAA8B;AAAA,EACvC,MAAM;AAAA,EACN,aAAa;AAAA,EACb,SAAS,CAAC,gBAAQ;AAAA,EAClB,YAAY,CAAC;AAAA,EACb,WAAW,CAAC,gBAAgB;AAAA,EAC5B,MAAM,OAAO,GAAG,YAA2B;AACzC,UAAM,UAAU,QAAQ;AAGxB,UAAM,QAAQ,MAAM,QAAQ,SAAS;AAAA,MACnC,MAAM,CAAC,SAAS,UAAU,sBAAsB;AAAA,IAClD,CAAC;AAED,eAAW,QAAQ,OAAO;AACxB,YAAM,QAAQ,WAAW,KAAK,EAAE;AAAA,IAClC;AAEA,YAAQ,mBAAmB;AAAA,MACzB,MAAM;AAAA,MACN,UAAU,OAAO,UAAU,UAAU,WAAW;AAC9C,eAAO;AAAA,MACT;AAAA,MACA,SAAS,OAAOC,UAAS,UAAU,SAAS;AAC1C,cAAM,MAAM,IAAI,cAAcA,QAAO;AACrC,YAAI;AACF,gBAAM,IAAI,WAAW;AAAA,QAEvB,SAAS,OAAO;AACd,UAAAC,QAAO,MAAM,kCAAkC,KAAK;AAEpD,UAAAD,SAAQ,WAAW,KAAK,EAAE;AAAA,QAC5B;AAAA,MACF;AAAA,IACF,CAAC;AAED,YAAQ,WAAW;AAAA,MACjB,MAAM;AAAA,MACN,aAAa;AAAA,MACb;AAAA,MACA,UAAU;AAAA,QACR,WAAW,KAAK,IAAI;AAAA,QACpB,WAAW,KAAK,IAAI;AAAA,QACpB,gBAAgB,MAAO,KAAK;AAAA;AAAA,MAC9B;AAAA,MACA,MAAM,CAAC,SAAS,UAAU,kBAAkB,WAAW;AAAA,IACzD,CAAC;AAAA,EAmBH;AACJ;AAEA,IAAO,gBAAQ;","names":["logger","logger","z","logger","runtime","logger"]}